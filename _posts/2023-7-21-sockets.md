---
layout: post
title: Let's Talk About Python Sockets
icon: python_sockets2.png
date: 2023-07-21
ready: true
show_date: true
---

<figure>
    <img class="mx-auto d-block blog-img" src="/assets/images/blog/python_sockets2.png" alt="python sockets">
    <figcaption class="text-center">High Quality Resolution Cartoon Drawing of a Python with Sockets - Prompt for Image Generated by DreamStudio </figcaption>
</figure>

Let's talk about Python sockets. I've debugged a good amount of code throughout my (short) career, but debugging socket issues has always been a weird one for me. Sometimes, the issue is as simple as trying to connect to the wrong port. Other times, your socket sends a packet off into the void and you're left wondering why the receiving end got no data. Each time a bug surfaces, I find myself using multiple debugging techniques, ranging from as simple as `printf()` debugging to as stupid as rubber duck debugging. In all cases, I've yet to come up with a reliable way to debug socket issues (yes, I should probably use WireShark).

Last Friday, I spent nearly 2 hours debugging some sockets code. Those 2 hours were the final straws that broke my back. And now, I officially have beef with the Python sockets API.

#### **The Final Straws**

Suppose we open two terminals and run the python interpreter on both. The first terminal is for creating a simple server for sending packets. The second terminal is for receiving packets from the server. Let's say we run the commands sequentially according to the `# Step X:` comments. 

<div class="row"><div class="col"><code> Terminal 1: </code><hr><pre>
import socket

HOST ='127.0.0.1'
PORT = 5678 

# Step 1: creating server socket
server = socket.socket(socket.AF_INET, 
                       socket.SOCK_STREAM)
server.bind((HOST,PORT))
server.listen(1)
server, _ = server.accept()













# Step 4: Close server 
server.close()

</pre></div><div class="col"><code> Terminal 2: </code><hr>
<pre>
import socket

HOST ='127.0.0.1'
PORT = 5678









# Step 2: creating client socket.
client = socket.socket(socket.AF_INET, 
                       socket.SOCK_STREAM)
client.connect((HOST, PORT))
client.setblocking(False)


# Step 3: Receive data
packet = client.recv(1024) <---
## a) Error or empty byte array? ##





# Step 5: Receive data again
packet = client.recv(1024) <---
## b) Error or empty byte array ##
</pre></div></div>


Here is what we are doing. First, we open a server socket in `Terminal 1`. Then, we open a client socket in `Terminal 2`. The **non-blocking** client socket attempts to receive data from the server. Since the server socket has not sent any data, the `recv` function will not return any data. **What is the expected behavior of the `recv` function in this scenario?** Will it throw an error or will it return an empty byte array (e.g. `b''`)?

After attempting to receive a packet, we close the server socket with the `close()` function. Lastly, we try to receive a packet from the server once again. **Will the second `client.recv(1024)` throw an error or will it return an empty byte array (e.g. `b''`)?** 

#### **The Beef**

<figure>
    <img class="mx-auto d-block blog-img" src="/assets/images/blog/python_sockets_behavior.png" alt="the beef">
    <figcaption class="text-center">Demonstration of the Behavior</figcaption>
</figure>

From the `recv` function [documentation](https://docs.python.org/3/library/socket.html#socket.socket.recv), I would have assumed `recv` returns an empty byte array on the first call. After all, there was nothing to receive! In fact, I think it would be a pretty intuitive and reasonable behavior for the `recv` function to return an empty byte array. Instead, the function throws a `BlockingIOError`, all because the server didn't send any data. This... makes no sense. Shouldn't errors be reserved for unacceptable behaviors? How is the client even supposed to know the server didn't send any packets?? Why would a client socket not be allowed to `recv` data??? I don't get it. 

On the other hand, the second `recv` function will return... an empty byte array. So, wait a second. A client can `recv` from a socket that's already been closed, but it can't receive data from a server that hasn't sent any packets? Why would the `recv` function work on a closed socket at all!! Throw an error goddamnit! 

**/endrant**

In all honesty, I kinda get it. I brought this upon myself because I defined a non-blocking client socket. But if it were up to me, I'd make it so the first `recv` call would return an empty byte array and the second call would throw an error. Just sayin'...